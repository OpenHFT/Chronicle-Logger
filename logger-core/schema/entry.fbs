namespace net.openhft.chronicle.logger.entry;

// This struct is to make it easy to nail down by second first,
// and then order by nano if necessary.
// It also makes pulling a java Instant easy through
// Instant.ofEpochSecond(epochSecond, nanoAdjustment)
struct EntryTimestamp {
  // The number of seconds since the epoch
  epoch_second:ulong;
  // Nanosecond adjustment inside the instant
  // always positive, never exceeds 999,999,999
  nano_adjust:int;
}

table Entry {
  // timestamp when the log event occured (required as a struct)
  timestamp: EntryTimestamp;

  // Logging level (may be custom per logging framework, always positive, could be more than 65,536)
  level:uint32;

  // logger name (required)
  logger_name:string (required);

  // thread name (optional)
  thread_name:string;

  // Serialized entry content as unsigned byte array.
  // Entry content is always serialized with zstandard, potentially with a dictionary.
  // A good assumption is that the data is application/json encoded as UTF-8, but
  // there is no constraint on data input, and it could be binary JSON like CBOR, msgpack, or SMILE.
  content: [ubyte];
}

root_type Entry;